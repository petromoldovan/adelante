### Aufgabe 2.1
A = (2, 4, 11, 12, 7, 15, 19)
n = 7

```
| m | i |           A               |  A[i] > A[i + 1] | isChange |  k   
|---|---|---------------------------|------------------|----------|-----
| 6 | 1 | (2, 4, 11, 12, 7, 15, 19) |       2 > 4      |     0    |
|   | 2 | (2, 4, 11, 12, 7, 15, 19) |       4 > 11     |     0    |
|   | 3 | (2, 4, 11, 12, 7, 15, 19) |       11 > 12    |     0    |
|   | 4 | (2, 4, 11, 12, 7, 15, 19) |       12 > 7     |     1    |  4
|   | 5 | (2, 4, 11, 7, 12, 15, 19) |       12 > 15    |     0    |  
|   | 6 | (2, 4, 11, 7, 12, 15, 19) |       12 > 15    |     0    |  
|---|---|---------------------------|------------------|----------|-----
| b = true, m = k - 1 = 4 - 1 = 3
|---|---|---------------------------|------------------|----------|-----
| 3 | 1 | (2, 4, 11, 7, 12, 15, 19) |       2 > 4      |     0    |
|   | 2 | (2, 4, 11, 7, 12, 15, 19) |       4 > 11     |     0    |
|   | 3 | (2, 4, 11, 7, 12, 15, 19) |       11 > 7     |     1    |  3
|---|---|---------------------------|------------------|----------|-----
| b = true, m = k - 1 = 3 - 1 = 2
|---|---|---------------------------|------------------|----------|-----
| 2 | 1 | (2, 4, 7, 11, 12, 15, 19) |       2 > 4      |     0    |
|   | 2 | (2, 4, 7, 11, 12, 15, 19) |       4 > 7      |     0    |
|---|---|---------------------------|------------------|----------|-----
| b = false => sorting is done!
|---|---|---------------------------|------------------|----------|-----
|   |   | (2, 4, 7, 11, 12, 15, 19) |                  |          | 
```

#2.2. Given is the array A = (11, 15, 13, 8, 1, 10, 16, 12). A is to be sorted in ascending order according to the recursive algorithm Quicksort of the script p. 54.
N = 8
###a. Perform the first division according to the Partition algorithm in the script.
i) Specify the swaps that occur as described in the script with the example partition(A, 1, 6)
   page 55.
```
| p | r |       A[1..8]         | x | j | A[j] ≤ x | i | A[i] ↔ A[j] | A[i] ↔ A[r] 
|---|---|-----------------------|---|---|----------|---|-------------|------------
| 1 | 8 |(11,15,13,8,1,10,16,12)| 12| 1 |    1     | 1 |  11 ↔ 11    |
|   |   |                       |   | 2 |    0     |   |             |
|   |   |                       |   | 3 |    0     |   |             |
|   |   |                       |   | 4 |    1     | 2 |  15 ↔ 8     |
|   |   |(11,8,13,15,1,10,16,12)|   | 5 |    1     | 3 |  13 ↔ 1     |
|   |   |(11,8,1,15,13,10,16,12)|   | 6 |    1     | 4 |  10 ↔ 1     |
|   |   |(11,8,1,10,13,15,16,12)|   | 7 |    0     |   |             |
|   |   |                       |   |   |          | 5 |             |    8 ↔ 5
|   |   |(11,8,1,10,12,15,16,13)|   |   |          |   |             |   
```

ii) 
Value of i = 5 IF we start array indexing with 1 as in the example. Otherwise, if we start
array indexing with 0, the returned value is i = 4.


###b. Display the entire process in a binary tree so that the recursive divisions of the array are shown. 

Divide:
```
 |                   (11,15,13,8,1,10,16,12)
 |                   (11,8,1,10,_12_,15,16,13)  
 |                  /                         \
 |            (11,8,1,10)                  (15,16,13)  
 |            (8,1,_10_,11)                (_13_,16,15)  
 |           /             \               /           \  
 |         (8,1)          (11)            ()            (16,15) 
 |         (_1_,8)                                      (_15_,16) 
 |         /   \                                       /         \
\_/       ()     (8)                                  ()           (16)
                            
```
Combine:
```
 _
/ \                 (1,8,10,11,12,13,15,16)
 |                        (_12_)  
 |                   /              \
 |             (1,8,10,11)           (13,15,16)  
 |             (_10_)                (_13_)  
 |            /      \               /     \  
 |          (1,8)    (11)          ()       (15,16) 
 |          (_1_)                           (_15_) 
 |          /   \                          /      \
 |        ()     (8)                      ()       (16)                           
```

Support calculations:
```
| Tiefe |       A[1..8]         | p | r | q | A[q] | Combine
|-------|-----------------------|---|---|---|------|--------------------------------
|   0   |(11,15,13,8,1,10,16,12)| 1 | 8 |   |      |                (1,8,10,11,12,13,15,16)
|       |(11,8,1,10,12,15,16,13)|   |   | 5 |  12  | 
----------------------------------------------------
|   1   |  (11,8,1,10)          | 1 | 4 |   |      |          (1,8,10,11)
|       |  (8,1,10,11)**        |   |   | 3 |  10  |
|   2   |    (8,1)              | 1 | 2 |   |      |      (1,8)
|       |    (1,8)*             |   |   | 1 |   1  |
|   3   |       ()              | 1 | 0 |   |      | ()
|   3   |      (8)              | 2 | 2 |   |      | (8)
|   2   |    (11)               | 4 | 4 |   |      |       (11)
----------------------------------------------------
|   1   |  (15,16,13)           | 6 | 8 |   |      |          (13,15,16)  
|       |  (13,16,15)           |   |   | 6 |  13  |
|   2   |    ()                 | 6 | 5 |   |      |         () 
|   2   |    (16,15)            | 7 | 8 |   |      |    (15,16)
|       |    (15,16)            |   |   | 7 |  15  |      
|   3   |      ()               | 7 | 6 |   |      |  ()
|   3   |      (16)             | 8 | 8 |   |      | (16)
 
```

Partition Calculations:
```
*
| p | r |       A               | x | j | A[j] ≤ x | i | A[i] ↔ A[j] | A[i] ↔ A[r] 
|---|---|-----------------------|---|---|----------|---|-------------|------------
| 1 | 2 |(8,1)                  | 1 | 1 |    0     | 0 |             |
|   |   |                       |   |   |          | 1 |             | 1 ↔ 8
|   |   |(1,8)                  |   |   |          |   |             | 
```
```
**
| p | r |       A               | x | j | A[j] ≤ x | i | A[i] ↔ A[j] | A[i] ↔ A[r] 
|---|---|-----------------------|---|---|----------|---|-------------|------------
| 1 | 4 |(11,8,1,10)            | 10| 1 |    0     |   |             |
|   |   |                       |   | 2 |    1     | 1 |  11 ↔ 8     |
|   |   |(8,11,1,10)            |   | 3 |    1     | 2 |  11 ↔ 1     |
|   |   |(8,1,11,10)            |   |   |          | 3 |             | 4 ↔ 3
|   |   |(8,1,10,11)            |   |   |          |   |             |
```
```
***
| p | r |       A               | x | j | A[j] ≤ x | i | A[i] ↔ A[j] | A[i] ↔ A[r] 
|---|---|-----------------------|---|---|----------|---|-------------|------------
| 6 | 8 |(15,16,13)             | 13| 6 |    0     | 5 |             |
|   |   |                       |   | 7 |    0     |   |             | 
|   |   |                       |   |   |          | 6 |             | 15 ↔ 13
|   |   |(13,16,15)             |   |   |          |   |             | 
```

#2.3. Please compile and run the file SortTest to see few tests run with QuickSort.
Please see the code in the Sort.java file. Test are available in the SortTest.java. 

#2.4. Test your Implementation with the file QuickSort.txt
Please run
```
javac SortTest.java
java SortTest
```
I got 160 361 comparisons with the QuickSort algorithm. 
Given that N = 10 000
a) n^2 = 100 000 000
b) n(n-1)/2 = 49 995 000
c) n Log n = 132 877 <-- best case is the closest fit.
